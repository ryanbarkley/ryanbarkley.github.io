<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Software Quality Isn't (Just) About Software &#183; Ryan Barkley</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/styles.css><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link href rel=alternate type=application/rss+xml title="Ryan Barkley"></head><body><nav class=nav><div class=nav-container><a href=/><h2 class=nav-title>Ryan Barkley</h2></a><ul><li><a href=/about/><span>About</span></a></li><li><a href=/projects/><span>Projects</span></a></li><li><a href=/resources/><span>Resources</span></a></li></ul></div></nav><main><div class=post><div class=post-info><span>Written by</span>
Ryan Barkley<br><span>Published&nbsp;</span><time datetime="2020-05-25 00:00:00 -0600 -0600">May 25, 2020</time>
&#183; <span>Updated&nbsp;</span><time datetime="2020-10-11 18:25:39 -0500 -0500">October 11, 2020</time></div><h1 class=post-title>Software Quality Isn't (Just) About Software</h1><div class=post-line></div><h2 id=opinions-everywhere>Opinions, Everywhere</h2><p>Ask a group of 10 developers what it means to write good code and you&rsquo;ll probably get 10 answers. One declares &ldquo;it works&rdquo;. Another suggests &ldquo;it runs quickly and can scale&rdquo;. Yet another contends &ldquo;it&rsquo;s easy to work with&rdquo;. Around the room the answers go; there&rsquo;s as many possible answers as there are opinions and being a group of developers there&rsquo;s certainly no shortage of those.</p><p>Which answer is correct? Are any of them? All of them? None of them? In fact, each of these answers touches on one aspect of what it means to write &ldquo;good code&rdquo;, yet none of them succeed in capturing the full scope of what that really means. Before we can accurately define what it means for code to be &ldquo;good&rdquo;, we must first examine the underlying reason we&rsquo;re writing code to begin with. Only then can we begin to reason from first principles to deduce what practical implications we can use to judge the quality of a particular piece of code.</p><h2 id=understanding-the-business-context>Understanding the Business Context</h2><p>Why do we write code? For fun, fame, and fortune? While that may be a personal motivation for some, it&rsquo;s usually not why we&rsquo;re hired. At the end of the day, we&rsquo;re employed to solve a business problem. More specifically, we&rsquo;re usually tasked with implementing a technical solution to solve a particular problem of a certain business subdomain—something that will ultimately either reduce costs or increase profit for the business that employs us. Intuitively, we can reason from this that &ldquo;good code&rdquo; must then be code that <em>solves a business problem</em>. Or, more precisely, we could say that <strong>good code solves more business problems than it creates</strong>. That&rsquo;s it. That&rsquo;s the Tweet.</p><p>Sorry, were you expecting a more &ldquo;technical&rdquo; answer? That&rsquo;s the trouble with us developers: we instinctively want to jump straight to a low-level technical solution before first understanding the greater business context in which we operate. As we&rsquo;ll soon see, there are <em>many</em> objective, technical qualities of &ldquo;good code&rdquo;, but without properly framing them with the business context we&rsquo;ll quickly descend into a world of &ldquo;differing opinions&rdquo; that is comprised of bickering and bikeshedding.</p><h2 id=does-quality-matter>Does Quality Matter?</h2><p>Some would argue that if code solves a business problem (i.e., &ldquo;it works&rdquo;), it would simply be wasteful to spend more time reworking the solution to &ldquo;refactor&rdquo; it just to pursue some abstract notion of &ldquo;code quality&rdquo;. If the goal of software development is to solve a business problem, it seems logical to assume that once we&rsquo;ve done that any additional effort expended would be considered &ldquo;waste&rdquo;. The issue with this view is that it misses a key component of the &ldquo;non-technical&rdquo; answer we reasoned above. We don&rsquo;t <em>just</em> need to solve business problems; we need to solve <em>more business problems than we create</em>. As it turns out, bad code can create <em>lots</em> of business problems. (Don&rsquo;t believe me? Just ask anyone who&rsquo;s ever worked on a legacy software system. Maybe throw in a comment or two along the lines of &ldquo;that seems like it should have been simple&rdquo; or &ldquo;I don&rsquo;t understand what was so difficult&rdquo; for good measure. Assuming they&rsquo;re still speaking to you at this point, I&rsquo;m sure you&rsquo;ll get some <em>very</em> detailed accounts of how long-ignored technical debt was dragging down both team productivity <em>and</em> morale.)</p><h2 id=bad-code--bad-business>Bad Code == Bad Business</h2><p>Every software developer who&rsquo;s spent any length of time writing professional software likely has their own definition of it, but there&rsquo;s one thing we&rsquo;re <em>all</em> familiar with: technical debt. We use this term to describe a wide range of less-than-ideal code—things we feel could be faster to run or easier to read as well as things we <em>really</em> hope don&rsquo;t come back to bite us later. (Spoiler: it will.)</p><p><strong>What&rsquo;s unfortunate about the term &ldquo;technical debt&rdquo; is that to a business, debt generally sounds like a <em>good</em> thing.</strong> Businesses are in, well, the <em>business</em> of using &ldquo;capital&rdquo; to produce &ldquo;profit&rdquo;. Often, that means borrowing other people&rsquo;s capital in the form of debt to make even more profit. Usually, however, this isn&rsquo;t the sort of situation we software developers have in mind when we label something as &ldquo;technical debt&rdquo;. In fact, what we&rsquo;re referring to is more akin to <em>high-interest</em> debt. Mountains of it. So much, in fact, that we&rsquo;re completely &ldquo;over-leveraged&rdquo; and no reputable lenders want to give us more money for fear we&rsquo;ll never pay it back. Leaving aside the place of privilege that leads one to think personal finance is entirely about being smarter or harder-working and not about uncontrollable life circumstances, every business person in the board room would likely be irrecoverably embarrassed to fall prey to the &ldquo;payday loan trap&rdquo;, yet due to an unfortunate misunderstanding of terminology this is <em>almost exactly</em> the same sort of situation that can arise with technical debt.</p><p><strong>When we incur technical debt, we&rsquo;re usually borrowing from our future selves.</strong> Payments against that &ldquo;debt&rdquo; are made in the form of time we could be spending working on other features to add new business value. The &ldquo;interest&rdquo; is paid by way of reduced &ldquo;throughput&rdquo; or &ldquo;feature velocity&rdquo;. (I.e., new features take longer to implement than they otherwise would.) The more &ldquo;debt&rdquo; we take out, the higher the &ldquo;interest rate&rdquo; we pay. As many discover much too late, there&rsquo;s a tipping point where eventually we are just treading water making &ldquo;interest-only payments&rdquo; and can&rsquo;t begin to fathom having the time to pay down the principle to get our rate lower. Left unchecked, this can lead to the &ldquo;spiral of death&rdquo; where we begin to fall behind on those &ldquo;interest-only payments&rdquo;, causing the technical debt to spiral out of control and leading to ruin. Depending on the project, that may mean the project is considered a failure, or it might mean an entire team or department gets the axe. At worst, it could represent an existential threat to the business itself. This is why technical debt is so insidious: it sounds like a good thing to those who don&rsquo;t understand software development, so the business implications often go unnoticed until it&rsquo;s too late and everyone&rsquo;s job is on the line.</p><h2 id=illusion-of-choice>Illusion of Choice</h2><p>Almost everything in software development is a tradeoff of some sort. Naturally, we assume that quality must be &ldquo;balanced&rdquo; with getting work out the door quickly, as if the two are competing goals. While perfect is the enemy of done, it&rsquo;s critical to understand that a high-quality codebase is what enables us to go more quickly in the future.</p><p>The takeaway from all of this is that when we think we are making a <em>choice</em> between &ldquo;quality&rdquo; and &ldquo;speed&rdquo;, we are gravely misunderstanding the very nature of our craft. While most decisions are indeed nuanced and full of trade-offs, the notion of choosing between &ldquo;quality&rdquo; and &ldquo;speed&rdquo; is fundamentally a false choice. Not only do the two coexist together in harmony, they are inherently intertwined, one enabling the other. Thinking otherwise is an illusion that would be unprofessional to perpetuate.</p><h2 id=hallmarks-of-good-code>Hallmarks of Good Code</h2><p>Aside from <strong>solving a business problem</strong> (i.e., &ldquo;it works&rdquo;), there are two primary attributes I consider when determining whether something <strong>solves more business problems than it creates</strong>. While There are <em>many</em> facets to these, I consider them to be the supersets to which all other qualities are sub-members when we consider code quality from a business context.</p><h3 id=attribute-1-good-code-is-maintainable>Attribute #1: Good code is maintainable.</h3><p><strong>Maintainable code can be extended <em>safely</em> and <em>efficiently</em>.</strong> I consider this to be the core principle from which all of the other observations regarding software maintainability mentioned below are derived.</p><p><strong>Automated tests provide safety when making changes.</strong> A fundamental part of being able to make changes <em>safely</em> is in having comprehensive automated tests that can be run against the codebase to tell us whether new changes will break existing functionality. The confidence we gain from these automated tests also helps us move more <em>efficiently</em> since they allow us to spend less time manually testing features and fixing things we didn&rsquo;t realize were broken until much later.</p><p><strong>Code is read more than it is written.</strong> Just think of the last time you implemented a code change to an existing software system. How much time was required to actually write new code to make your change as opposed to the time you spent reading the existing code to understand how things currently worked? Because of this imbalance, we should optimize for readability as much as we reasonably can to make the job easier for our future selves and other developers. This includes things like consistent formatting and good naming, but also involves implementing solutions that are idiomatic to the language and framework being used.</p><p><strong>Well-factored code reads like good prose.</strong> (Assuming you&rsquo;re working with an adequately expressive high-level programming language anyway.) Martin Fowler <a href=https://en.wikiquote.org/wiki/Martin_Fowler>once famously said</a> &ldquo;Any fool can write code that a computer can understand. Good programmers write code that humans can understand.&rdquo;</p><p><strong>Good naming is one of the single most important things you can practice.</strong> There&rsquo;s a running joke in the industry that there are two hard things in Computer Science: naming things, cache invalidation, and off-by-one errors. Clear, descriptive variable names are well-worth the effort and can provide great benefits to the maintainability of a codebase. I&rsquo;ve often found that if I&rsquo;m having trouble giving something a good name, it&rsquo;s an indication that I either don&rsquo;t understand it well enough yet myself or a function is trying to do too much and needs to be refactored further.</p><p><strong>Comments should provide context, not captions.</strong> If you&rsquo;re working in an expressive, high-level language, there should be very little need for comments in well-factored code that adheres to good naming principles. If you find yourself using comments to describe <em>what</em> the code is doing, it&rsquo;s probably a code smell that should be refactored. (Remember, we want the solution to be <em>simple</em> and <em>obvious</em>. Much like a joke, if you have to explain it the code probably isn&rsquo;t very good.) The primary role of comments should be for providing <em>context</em> on why things are done a particular way or certain decisions were made when implementing a solution.</p><p><strong>Code should be unsurprising and honest.</strong> Professional code isn&rsquo;t the place for <a href=https://en.wikipedia.org/wiki/Code_golf>golfing</a> or proving how clever you are. Ideally, reading code should be a boring activity without plot twists. Things should do exactly what they claim to do without lying about their purpose in their names.</p><h3 id=attribute-2-good-code-is-scalable>Attribute #2: Good code is scalable.</h3><p><strong>Scalable code is about more than just supporting an increased user count or larger data set.</strong> Those are certainly key aspects of scalability, mind you. Every professional software developer should be able to reason about the basic time and space complexity tradeoffs of their code and understand at least the basics of big-O notation. What many developers overlook, however, is two other key aspects in which code needs to scale: team size and feature count.</p><p><strong>Successful code will see many developers over its lifespan.</strong> A high-quality codebase is one that new developers can easily pick up and begin working in productively. If you find that only the original developers of a system can be productive in a particular codebase and new developers never seem to be as productive as you&rsquo;d like, you may be served well to reconsider whether every new developer is really the problem or if maybe the problem is with your existing codebase. (Spoiler: if you have to ask, it&rsquo;s probably your codebase.)</p><p><strong>Codebases often start off with only a few developers but end up with many developers over time.</strong> Managing a codebase that&rsquo;s actively worked on by 20-30+ developers is vastly different from managing one where only 2-3 people contribute code. With an order of magnitude of team growth, the previous economies of scale for things like code organization, version control, and deployment practices probably don&rsquo;t hold. Things that were once simple are now exceedingly complex, creating a new form of technical debt where there wasn&rsquo;t any previously. While it&rsquo;s important to avoid premature optimization, keeping team growth in mind from the start can save a lot of pain later.</p><p><strong>Code should support new and changing business needs.</strong> While many will pursue &ldquo;DRY code&rdquo; as a &ldquo;pure good&rdquo;, I&rsquo;ve found that doing so can often be a misguided attempt that leads to what I like to call &ldquo;DRY-rot&rdquo;. Good abstractions are an important part of scaling a codebase to support new features, but having no abstraction is usually preferable to having a poor one. Once again, it&rsquo;s important to avoid premature optimization and making overly-generic code can often just make it more difficult to implement a feature now <em>and</em> make it more difficult to extend later. Adhering to principles such as SOLID will go a long way towards ensuring code can support new and changing needs later. Although originally conceived for OOP, I&rsquo;ve found the principles outlined in SOLID to be applicable far beyond the scope of just objects and classes.</p><p><strong>Code should support business growth.</strong> The success of our business goals shouldn&rsquo;t come as a surprise that overwhelms the software system and brings it crashing to a halt. Premature optimization should be avoided, but careful attention should be given to how a solution will scale under increased load, whether by way of additional users or larger data sets. Not every aspect needs to be optimized up front, but it&rsquo;s important to make sure that we don&rsquo;t paint ourselves into a corner where it&rsquo;s exceedingly difficult to implement an optimization later for no better reason than we simply didn&rsquo;t take care to think about what would happen if our business actually succeeded.</p><h2 id=software-professionalism>Software Professionalism</h2><p><strong>Good code isn&rsquo;t just a question of developer happiness or business performance; it&rsquo;s one of professionalism.</strong> As software developers, we are hired by the business to achieve business outcomes by using technology—often by business stakeholders who truly don&rsquo;t understand all the nuances and implications of the tradeoffs we&rsquo;re faced with on a daily basis. It is our responsibility to use our expertise to help the business reach its objectives; that means writing good code and helping others do the same.</p><p><strong>Careful attention must be given to promote code quality.</strong> If left unchecked, we may find ourselves excusing certain bits of code since we want to &ldquo;make the deadline&rdquo; or some other reason we tell ourselves about why it&rsquo;s okay to do a bad job &ldquo;just this once&rdquo;. If the deadline is fixed, scope should be the primary variable we consider for fluctuation, not quality, since as we&rsquo;ve seen quality is a core component of being able to reach business objectives.</p><p><strong>Without proper care, bad code can quickly ruin an entire codebase.</strong> Much like a broken window can lead to an entire building falling into disrepair, so too can bad code in one corner of a codebase lead to a global decrease in code quality for the entire application. If the linter output has one warning, others will soon follow. After all, it&rsquo;s just a warning and the code still compiles, so &ldquo;it works&rdquo;, right? (If you&rsquo;ve read this far, I hope you know how naive this understanding is.)</p><p><strong>High-quality code is respectful to future developers (including yourself).</strong> Instead of taking the &ldquo;easy&rdquo; way out by rushing out poor quality code, think about the complete lifecycle of the code you&rsquo;re writing. At some point down the road, someone (likely you or a teammate) will likely have to extend or modify the code you write today. Often, a few extra minutes today can save hours or days of rework in the future.</p><h2 id=good-coding-practices>Good Coding Practices</h2><p>Now that we understand the greater business context and what it really means to write &ldquo;good code&rdquo;, lets examine some specific practices and principles that promote that end.</p><p><strong>A mindset of continuous learning and study is the foundation of software craftsmanship.</strong> Fortunately, it is not to us to discover the core principles of how to write quality software. While there exists a bright future of innovation ahead of us, we stand on the shoulders of giants and there are certain guiding principles which have been discovered and documented for us to learn from. Specifically, <strong>SOLID coding principles provide the basis for many concepts and practices</strong> that are universally applicable far beyond the scope of strongly-typed OOP.</p><p><strong>Code reviews and pair programming promote software quality through shared learning.</strong> Sometimes we&rsquo;ve worked on a problem for so long that we miss obvious errors or potential ways to achieve a more optimal solution. Having a peer involved in the development process helps provide valuable feedback towards achieving a better implementation. As an added benefit, it also means that someone else is familiar with that portion of the codebase, which helps promote team knowledge sharing.</p><p><strong>Test-Driven Development (TDD) promotes thorough code coverage in automated test suites.</strong> While there are many differing opinions on the &ldquo;best&rdquo; way to test code, the single most important principle is that you <em>are</em> testing your code in an automated fashion. Quality drives future productivity when working in a codebase; a key component of that is knowing we didn&rsquo;t break anything with our latest changes.</p><p><strong>Automated code analysis elevates the level of our problem solving.</strong> Most professional software development teams have a style guide they seek to adhere to. Without proper tooling, it&rsquo;s easy for code reviews and other forms of peer feedback to become mired in trivialities such as formatting and syntax errors. Static analysis of our code using code linters and automated formatting tooling (e.g., <a href=https://eslint.org/>ESLint</a> and <a href=https://prettier.io/>Prettier</a> for JavaScript) can eliminate entire categories of potential issues from the scope of concern of human review. In addition to being a great productivity boost, it can also serve as a way to prevent bikeshedding within the team—any change to the style guide is now a Pull Request to change the configuration for the tool that enforces it.</p><p><strong>Objective metrics derived through static analysis can provide a way to track code quality changes over time.</strong> In addition to streamlining concerns around style guide adherence and basic syntax issues, static analysis tooling can also be used to derive helpful metrics that provide an indication of code quality. (E.g., cyclomatic complexity, function LOC, framework-specific best practices and security issues, etc.) While much of coding is indeed an art, there is a great deal that can be reduced to objective science.</p><p><strong>Using a CI check for each Pull Request is a great way to enforce code quality.</strong> By implementing various static analysis metrics as <em>fitness functions</em> that we can run against our code, we can create <em>quality gates</em> to allow or block changes based on predefined rules. Manual review still serves an important role in team knowledge sharing and in promoting overall code quality, but trivial issues such as syntax errors and style guide violations should never make it into <code>main</code>. This is also a great place to run automated test suites to ensure that the <em>function</em> of the code is correct in addition to its <em>form</em>. (Running code in this way is an example of <em>dynamic analysis</em>, which is closely related to the <em>static analysis</em> tooling described above.)</p><p><strong>Ongoing attention and care help improve code quality in the long run.</strong> Some teams enforce a policy that PR to a repo may only touch code <em>directly</em> related to a the feature at hand, but I&rsquo;ve found that such heavy-handed rules can serve as an unnecessary point of friction for simple fixes. While sweeping formatting changes and large refactorings should certainly be done in their own branch, smaller fixes usually cause no harm and are more likely to actually get done when allowed to be &ldquo;batched&rdquo; with other nearby changes in an otherwise &ldquo;unrelated&rdquo; PR.</p><h2 id=guiding-principles>Guiding Principles</h2><p>Code quality isn&rsquo;t just a nice-to-have to promote developer happiness; rather it is an integral component of meeting business needs. <strong>High quality code directly improves business outcomes</strong> by making it easier for developers to maintain code and scale it to meet future needs. For more on that topic, I&rsquo;d highly recommend Martin Fowler&rsquo;s excellent article titled &ldquo;<a href=https://martinfowler.com/articles/is-quality-worth-cost.html>Is High Quality Software Worth the Cost?</a>&rdquo;.</p></div><div class=pagination><a href=/posts/personal-digital-security/ class="left arrow">&#8592;</a>
<a href=# class=top>Top</a></div></main><footer><span>&copy; <time datetime="2022-11-20 17:16:37.890569477 +0000 UTC m=+0.065393250">2022</time> Ryan Barkley. Made with <a href=https://gohugo.io>Hugo</a> using the <a href=https://github.com/EmielH/tale-hugo/>Tale</a> theme.</span><br><span><a href=https://twitter.com/ryanbarkley>Twitter</a> &#183;
<a href=https://hachyderm.io/@ryanbarkley rel=me>Mastodon</a> &#183;
<a href=https://github.com/ryanbarkley>GitHub</a> &#183;
<a href=https://www.linkedin.com/in/ryanbarkley>LinkedIn</a></span></footer></body></html>